# 완전이진트리 => 
# 특징 : 1. 노드 개수 = 2**k - 1
#       2.  노드 개수는 무조건 홀수
#       3.  배열의 중앙 값이 root node   
# 중위 순회

import sys

input = sys.stdin.readline

k = int(input()) # 트리의 깊이
i = list(map(int, input().strip().split())) # 중위 순회 결과
levels = [[] for _ in range(k)] # k가 3인 경우, level = [[],[],[]]

def dfs(arr, depth):
    # 종료 조건
    if not arr:
        return
    
    # 중위 순회는 중앙값이 루트 노드
    mid = len(arr) // 2

    # 현재 깊이의 레벨에 중간값을 추가, [[3],[],[]]이 된다
    levels[depth].append(arr[mid])

    #   Depth 1: 선택된 노드 = 3
    #   현재 배열: [1, 6, 4, 3, 5, 2, 7]
    #   왼쪽 서브트리: [1, 6, 4]
    #   오른쪽 서브트리: [5, 2, 7]

    dfs(arr[:mid], depth + 1) #   왼쪽 서브트리: [1, 6, 4], 중간 값이 6, level = [[3], [6], []]

    dfs(arr[mid+1:], depth + 1) # 오른쪽 서브트리

dfs(i, 0)

for level in levels:
    print(' '.join(map(str, level)))


# Depth 1: 선택된 노드 = 3
# 현재 배열: [1, 6, 4, 3, 5, 2, 7]
# 왼쪽 서브트리: [1, 6, 4]
# 오른쪽 서브트리: [5, 2, 7]
# ---
# Depth 2: 선택된 노드 = 6
# 현재 배열: [1, 6, 4]
# 왼쪽 서브트리: [1]
# 오른쪽 서브트리: [4]
# ---
# Depth 3: 선택된 노드 = 1
# 현재 배열: [1]
# 왼쪽 서브트리: []
# 오른쪽 서브트리: []
# ---
# Depth 3: 선택된 노드 = 4
# 현재 배열: [4]
# 왼쪽 서브트리: []
# 오른쪽 서브트리: []
# ---
# Depth 2: 선택된 노드 = 2
# 현재 배열: [5, 2, 7]
# 왼쪽 서브트리: [5]
# 오른쪽 서브트리: [7]
# ---
# Depth 3: 선택된 노드 = 5
# 현재 배열: [5]
# 왼쪽 서브트리: []
# 오른쪽 서브트리: []
# ---
# Depth 3: 선택된 노드 = 7
# 현재 배열: [7]
# 왼쪽 서브트리: []
# 오른쪽 서브트리: []
# ---
# 재귀 함수 호출 종료

# 3
# 6 2
# 1 4 5 7


